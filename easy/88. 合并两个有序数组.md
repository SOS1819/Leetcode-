### 题目描述

给定两个有序整数数组 *nums1* 和 *nums2*，将 *nums2* 合并到 *nums1* 中*，*使得 *num1* 成为一个有序数组。

**说明:**

- 初始化 *nums1* 和 *nums2* 的元素数量分别为 *m* 和 *n*。
- 你可以假设 *nums1* 有足够的空间（空间大小大于或等于 *m + n*）来保存 *nums2* 中的元素。

**示例:**

```
输入:
nums1 = [1,2,3,0,0,0], m = 3
nums2 = [2,5,6],       n = 3

输出: [1,2,2,3,5,6]
```

### 解题方法

一般来说，我们都是给定两个数组并返回一个新数组，这样我们就可以直接向新数组中添加元素，但是这道题目要求我们直接添加在 *nums1* 上，不过它的大小大于等于 `m + n` 。

如果我们按照平常方法，直接将元素向 *nums1* 从头部开始添加的话，我们就会涉及到元素的更改以及移动，这样会增加复杂度。题目毕竟指明了 *nums1* 数组的大小为 `>= m + n` ，也就是说除了 `m` 个自身的元素之外，后面的元素都是空着的，如果我们从 `m + n - 1 ` 的位置开始添加的话，就算 *nums2* 中的 `n` 个元素全部添加到 *num1* 尾部也不需要考虑元素更改和移动问题。

在平常方法中，我们之所以在数组头部添加元素是因为我们是选择小的添加，那么我们从尾部添加就要选取两个数组中的较大值加入数组。也就是说，我们需要逆序遍历两个数组。

#### 算法步骤

- 初始化 `index = m + n - 1` ，代表 *nums1* 数组中当前需要被确定值的元素索引。
- 当 `m > 0` 或者 `n > 0` 时循环：
  - 若`m > 0 && n > 0` ，选取 `nums1[m - 1]` 以及 `nums2[n - 1]` 中的较大值赋值给 `nums1[index]`，同时需要更新 `index` 以及对应 `m` 和 `n`
  - 否则表明一个数组已经遍历结束，选择不为空的数组（判断索引是否等于0即可）的值赋值给 `nums1[index]` 即可

#### 代码

```java
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        if(nums1 == null || nums2 == null)    return;
        int index = m + n - 1;
        while(m > 0 || n > 0){
            if(m > 0 && n > 0){
                nums1[index--] = nums1[m - 1] > nums2[n - 1] ? nums1[--m] : nums2[--n];
            }else{
                nums1[index--] = m > 0 ? nums1[--m] : nums2[--n];
            }
        }
    }
}
```

#### 复杂度

- 时间复杂度：$O(m + n)$
- 空间复杂度：$O(1)$