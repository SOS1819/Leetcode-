### 题目描述

将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。

本题中，一个高度平衡二叉树是指一个二叉树*每个节点* 的左右两个子树的高度差的绝对值不超过 1。

**示例:**

```
给定有序数组: [-10,-3,0,5,9],

一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：

      0
     / \
   -3   9
   /   /
 -10  5
```

### 解题方法

首先，您需要知道的是 **二叉搜索树** 的意义以及 **中序遍历** 的意义。

##### 二叉搜索树

> 对于树中任意一节点 `o` ，那么其左子树中节点的值均小于节点 `o` 的值，其右子树中节点的值均大于节点 `o` 的值。

##### 中序遍历

> 对于树中任意一节点 `o`，我们始终要先访问 `o` 的左子树的值，再访问 `o` 的值，最后再访问 `o` 的右子树的值。

官方题解中的图片解释：

![img](https://pic.leetcode-cn.com/Figures/108/bfs_dfs.png)

那么我们可以得到一个结论：**一个有序数组可以看成一棵二叉搜索树的中序遍历序列** 。

那么我们的题目也就转换为：**给定一棵二叉搜索树的中序遍历序列，还原对应的二叉搜索树**

接下来我们还需要知道，**仅仅按照中序遍历序列是无法还原唯一的二叉树的** 。官方题解中有这么一张图片可以很直接的展示：

![img](https://pic.leetcode-cn.com/Figures/108/bst2.png)

现在题目要求我们转换为一棵 **高度平衡的二叉搜索树**（一个二叉树*每个节点* 的左右两个子树的高度差的绝对值不超过 1）。

那么，**只要我们能够做到为每个节点的左右子树分配尽量平均的孩子节点数**，那么我们就能生成高度平衡的二叉搜索树了。那么对于数组而言，我们可以很轻松的做到这一点。

比如，对于数组 `[-10,-3,0,5,9]` ，我们需要为其选择一个根节点 `root`，那么在 `root` 左边的即为其左子树的节点，右边的即为右子树的节点，为了做到尽量平均，我们可以取数组的中点元素 `0` 。那么，左子树节点的值为 `[-10,-3]` ，右子树节点的值为 `[5,9]` 。当然，这是数组元素个数为奇数的情况，这时我们可以做到高度差为 `0` 。如果为偶数，我们的高度差也不会超过 `1` 。

现在我们可以继续处理左子树 `[-10,-3]` 和右子树 `[5,9]` 了。

只拿左子树举例，我们继续选取中点元素，得到 `-10` ，那么其左子树不存在元素，也就是左子树为空，右子树为 `[-3]` 。继续对 `[-3]` 处理即可。

最后我们可以得到二叉搜索树如下所示：

```
      0
     / \
   -10  5
     \   \
     -3   9
```

那么为了完成上述过程，需要利用 **递归** 。

#### 递归参数说明

- `left`：当前处理子树节点元素区间在数组 `nums` 中的左边界索引
- `right`：当前处理子树节点元素区间在数组 `nums` 中的右边界索引

- 函数返回参数：当前处理子树的根节点

#### 算法步骤

- 若 `left > right` ，说明不存在子树，返回 `null` 即可
- 取区间 `[left, right]` 中点元素索引 `rootIdx = (left + right) >> 1` ，生成对应值的根节点 `root`
- 递归区间 `[left, rootIdx - 1]` 作为 `root` 左子树
- 递归区间 `[rootIdx + 1, right]` 作为 `root` 右子树

#### 代码

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    private int[] nums;

    private TreeNode helper(int left, int right){
        if(left > right)    return null;
        int rootIdx = (left + right) >> 1;
        TreeNode root = new TreeNode(nums[rootIdx]);
        root.left = helper(left, rootIdx - 1);
        root.right = helper(rootIdx + 1, right);
        return root;
    }

    public TreeNode sortedArrayToBST(int[] nums) {
        if(nums == null)    return null;
        this.nums = nums;
        return helper(0, nums.length - 1);
    }
}
```

#### 复杂度

- 时间复杂度：$O(n)$ （我们需要访问每个元素）
- 空间复杂度：$O(n)$ （我们需要存储每个元素，除此之外，还需要 $log(n)$ 的系统栈空间）

