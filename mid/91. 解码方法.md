### 题目描述

一条包含字母 `A-Z` 的消息通过以下方式进行了编码：

```
'A' -> 1
'B' -> 2
...
'Z' -> 26
```

给定一个只包含数字的**非空**字符串，请计算解码方法的总数。

**示例 1:**

```
输入: "12"
输出: 2
解释: 它可以解码为 "AB"（1 2）或者 "L"（12）。
```

**示例 2:**

```
输入: "226"
输出: 3
解释: 它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6) 。
```

### 解题方法

**算法思想：动态规划**

我们创建一个数组 `dp[i]` ，代表解码到第 `i` 个数字的解码方法总数 。

转移方程为：$dp[i] = dp[i - 1] + dp[i - 2]$ ，就是说，当前解码方法数 = 当前数字为一个单独字母（相当于延续上一个数字的方法综述） + 当前数字加前一个数字作为一个字母（相当于延续第 `i - 2` 数字的解码方法总数） 。也就是斐波那契了。

比如 `226`，`dp[1] = 1` ，`dp[2] = 2` ，`dp[3] = 3` 。

#### 优化

为了节约空间，其实我们只需要使用三个变量就可以完成上述过程了，这也是斐波那契常用的优化。即用三个变量`ans` ，`num1`，`num2` 来代表对应的 `dp[i]` ，`dp[i - 1]` 和 `dp[i - 2]` 。

#### 注意点

- **初始化**

  给定的数据中可能会含有 `0` ，因此我们初始化时需要进行判断。

  首先，如果首位为 `0` ，那么其实就不可能存在解码方法了。因为此时无法形成单个 `0` 对应的字母，同时如果是 `01` 之类的由`0` 开头的两个数字形成的也是错误的。这时我们可以直接返回，如果不返回的话，想统一求解过程，就需要注意初始化操作了。

  - 若首位为 `0` ，那么`ans = num1 = num2 = 0` 即可。
  - 若不为 `0` ，那么 `ans = num1 = num2 = 1` ，即对于首位元素形成的序列存在 `1` 种解码方法，而对于由前两位元素形成的序列而言，其 ` num1(dp[i - 1])` 应该为 `1` ，另外 `num2(dp[i - 2])` 也应该为 `1` ，因为其可能形成对应的解码方法（为什么是可能？因为还需要判断当前数字是否为 `0` ，以及当前数字以及前一位数字形成的数字是否正确，下一点将会提到）

- **条件判断**

  我们这里将要确定 `ans` 的值。

  正常情况下，我们按照转移方程写即可，但是需要考虑如下特殊情况：

  - 若当前数字为 `0` ，那么 `num1` 为 `0` ，因为当前数字无法作为一个单独数字进行解码，也就是说前 `num1` 种能够造成当前数字为 `0` 的方法是无效的
  - 若前一个数字为 `0` ，那么 `num2` 为 `0` ，因为以 `0`  开头的两位数也是不合法的
  - 若当前一个数字不为 `0` ，但是两位数字形成数字的范围在 `[1,26]` 之外，那么也是错误的， `num2` 应该为 `0` 

#### 代码

```java
class Solution {
    public int numDecodings(String s) {
        if(s == null || s.length() == 0)    return 0;
        int length = s.length();
        int num1 = s.charAt(0) == '0' ? 0 : 1, num2 = num1, ans = num1;
        for(int i = 1; i < length; i++){
            int tmp = s.charAt(i) - '0' + (s.charAt(i - 1) - '0') * 10;
            num1 = s.charAt(i) == '0' ? 0 : num1;		// num1判断
           	// num2判断
            num2 = s.charAt(i - 1) == 0 ? 0 : tmp >= 1 && tmp <= 26 ? num2 : 0;
            ans = num1 + num2;
            num2 = num1;
            num1 = ans;
        }
        return ans;
    }
}
```

#### 复杂度

- 时间复杂度：$O(n)$
- 空间复杂度：$O(1)$