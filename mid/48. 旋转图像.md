### 题目描述

给定一个 *n* × *n* 的二维矩阵表示一个图像。

将图像顺时针旋转 90 度。

**说明：**

你必须在**[原地](https://baike.baidu.com/item/原地算法)**旋转图像，这意味着你需要直接修改输入的二维矩阵。**请不要**使用另一个矩阵来旋转图像。

**示例 1:**

```markdown
给定 matrix = 
[
  [1,2,3],
  [4,5,6],
  [7,8,9]
],

原地旋转输入矩阵，使其变为:
[
  [7,4,1],
  [8,5,2],
  [9,6,3]
]
```

**示例 2:**

```markdown
给定 matrix =
[
  [ 5, 1, 9,11],
  [ 2, 4, 8,10],
  [13, 3, 6, 7],
  [15,14,12,16]
], 

原地旋转输入矩阵，使其变为:
[
  [15,13, 2, 5],
  [14, 3, 4, 1],
  [12, 6, 8, 9],
  [16, 7,10,11]
]
```

### 解题方法

#### 主要思想

> 数组+模拟

#### 具体思路

从例子出发，现以数据1为例：

|  1   |  2   |  3   |
| :--: | :--: | :--: |
|  4   |  5   |  6   |
|  7   |  8   |  9   |

从行和列的角度来看，我们可以将翻转过程解释为：

1. 第一行作为第三列
2. 原来的第三列作为第三行
3. 原来的第三行作为第一列
4. 原来的第一列作为第一行

我们从上述角度进行细分，按照元素之间的交换可以将翻转过程解释为：

1. `matrix[0][2] = matrix[0][0]` ， `matrix[1][2] = matrix[0][1]` , `matrix[2][2] = matrix[0][2] `
2. ...（省略）
3. ...（省略）
4. ...（省略）

如果您可以把上面元素交换的过程完整写下来，那么可能您也会发现，第一行的三个元素与第三列的三个元素进行交换时，存在着相似性。那么我们现在换一种思路来对翻转过程进行解释，并找到这种相似性：

1. 在表格中，可以发现 `matrix[0][0]` , `matrix[0][2]` ， `matrix[2][2]` , `matrix[2][0]` 四个元素是会相互之间发生翻转的，具体过程是：
   - `matrix[0][2] = matrix[0][0]` 
   - `matrix[2][2] = matrix[0][2](原来的)`
   - `matrix[2][0] = matrix[2][2](原来的)`
   - `matrix[0][0] = matrix[2][0](原来的)`

2. 同样，我们也可以发现 `matrix[0][1]` , `matrix[1][2]` ，`matrix[2][1]` ，`matrix[1][0]`四个元素也可以相互翻转，其过程如下：
   - `matrix[1][2] = matrix[0][1]` 
   - `matrix[2][1] = matrix[1][2](原来的)`
   - `matrix[1][0] = matrix[2][1](原来的)`
   - `matrix[0][1] = matrix[1][0](原来的)`

那么，如果我们可以从第一行的每个元素为起点，按照上述过程完成四个元素的翻转，那么当遍历完第一行的元素（**最后一个除外，因为，第一行的第一个会翻转到第一行最后一个上，因此其不是我们的起点**），我们就完成了上述例子的翻转了。

因此，我们需要找到这四个**元素翻转的规律**，或者直接点说是**坐标转换的规律**。

我们假设第一行的起点为 `i` （这里初始化为 `0` ），终点为 `j` （初始化为 `n - 1`）

**由于矩阵是 `n x n` 的，因此我们也可以对 `i` 和 `j`进行另一种解释，即 `(i,i)` 为矩阵的左上角的元素索引， `(j,j) 为右下角元素索引`**

假设 `k` 是第一行的第 `k + 1` 个元素，因此初始化为 `0` 

那么，我们可以得到如下规律：

- 第 `j` 列的元素（不包括 `(j,j)`），是由第 `i` 行元素（不包括`(0, j)`，**下面不会再做特别说明**）翻转过来的

  我们可以得到如下转换方程： ``matrix[i + k][j] = matrix[i][i + k]`

- 第 `j` 行的元素是由原来第 `j` 列的元素翻转过来的，转换方程如下所示：`matrix[j][j - k] = matrix[i + k][j]`

- 第 `i` 列的元素是由原来第 `j` 行的元素翻转过来的，转换方程如下所示：`matrix[j - k][i] = matrix[j][j - k]`

- 第 `i` 行的元素是由原来第 `i` 列的元素翻转过来的，转换方程如下所示：`matrix[i][i + k] = matrix[j - k][i]`

根据上面的转换方程，我们在 `k + i < j` 时循环进行转换，便可以把 **外面一圈** 转换完成。

因此，当矩阵为 `4 x 4` 时，我们使用上述循环一次，就能把最外面一圈转换完成，但是怎么继续转换里面的呢？

> **由于矩阵是 `n x n` 的，因此我们也可以对 `i` 和 `j`进行另一种解释，即 `(i,i)` 为矩阵的左上角的元素索引， `(j,j) 为右下角元素索引`**

这时上面提到的，那么我们可以想到的就是，在矩形中，有了左上角和右下角就可以确定矩形，也就是说可以确定我们所要转换的圈。因此，需要转换内层圈，我们只要让 `i++ ` ， `j--` 即可，直到 `i >= j`

#### 代码

```java
class Solution {
    public void rotate(int[][] matrix) {
        if(matrix == null)    return;
        int i = 0, j = matrix[0].length - 1, tmp1, tmp2, tmp3;
        while(i < j){
            // 转换
            for(int k = 0; k + i < j; k++){
                tmp1 = matrix[i + k][j];
                matrix[i + k][j] = matrix[i][k + i];
                tmp2 = matrix[j][j - k];
                matrix[j][j - k] = tmp1;
                tmp3 = matrix[j - k][i];
                matrix[j - k][i] = tmp2;
                matrix[i][k + i] = tmp3;
            }
            // 缩圈
            i++;
            j--;
        }
    }
}
```

