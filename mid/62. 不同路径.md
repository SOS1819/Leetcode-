### 题目描述

一个机器人位于一个 *m x n* 网格的左上角 （起始点在下图中标记为“Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。

问总共有多少条不同的路径？

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/robot_maze.png)

例如，上图是一个7 x 3 的网格。有多少可能的路径？

**说明：** *m* 和 *n* 的值均不超过 100。

**示例 1:**

```markdown
输入: m = 3, n = 2
输出: 3
解释:
从左上角开始，总共有 3 条路径可以到达右下角。
1. 向右 -> 向右 -> 向下
2. 向右 -> 向下 -> 向右
3. 向下 -> 向右 -> 向右
```

**示例 2:**

```
输入: m = 7, n = 3
输出: 28
```

### 解题方法

#### 算法思想

动态规划

#### 算法实现

我们定义一个数组 `dp[i][j]` ，其代表从左上角 `(1,1)` 到达该点的可能路径数。

那么显然， `dp[1][1] = 1` 。

由于只能向下或者向右移动一步，因此我们可以得到转移方程：$dp[i, j] = dp[i - 1][j] + dp[i][j - 1]$ 。代表当前点的路径数是其左边点与上方点的路径之和。

**注意： 初始化时我们需要使得 dp[1，1] = 1 ,按照转移方程需要令 `dp[0][1]` 或者 `dp[1][0]`的一个为0，一个为1，并且其他 `dp[0][i]` 和 `dp[i][0]` 为 `0`** 

#### 代码

```java
class Solution {
    public int uniquePaths(int m, int n) {
        int[][] dp = new int[m + 1][n + 1];
        for(int i = 0; i < m; i++)    dp[i][0] = 0;
        for(int i = 0; i < n; i++)    dp[0][i] = 0;
        dp[0][1] = 1;
        for(int i = 1; i <= m; i++){
            for(int j = 1; j <= n; j++){
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
        return dp[m][n];
    }
}
```

#### 空间优化

我们可以用一个数组 `dp[n]` 来记录解，因为从上面看出，我们在内层循环中只是在计算一层的结果，如果我们能记住上层结果并进而利用，便可以将空间进行优化为 $O(n)$ 。

`dp[i]` ：代表从左上角 `(0,0)` 到达当前层（外层循环数）第 `i` 列的可能路径数。初始化全为 `1` ，代表到达第一层的每一列的可能路径数为 `1`，因为只能向右走。

首先先给出转移方程： $dp[j] = dp[j] + dp[j - 1]$ 。

代码部分为 ：

```java
for(int i = 1; i < m; i++){
    for(int j = 1; j < n; j++){
        dp[j] = dp[j] + dp[j - 1];
    }
}
```

`i` 代表当前计算的层数（第 `0` 层开始计算），`j` 代表计算的列数（第 `0` 列开始计算）

**过程简要分析：**

初始化时，我们将 `dp` 数组全部初始化为 `1`，现在计算第 `2` 层的结果。

假设我们计算当 `j = 1` 时（即点`(1, 1)`）的结果，那么 `dp[1] = dp[1] + dp[0]`

来仔细研究一下其中的含义：

由于只能向下或者向右移动，因此点 `(1, 0)` 只能由点 `(0, 0)` 向下移动得到，那么也就是说到达点 `(0, 0)` 的路径数与到达 `(1, 0)` 的路径数是相同的，映射到 `dp` 数组就是 `i = 1` 时的 `dp[0]` 与 `i = 0` 时的 `dp[0]` 是相等的，因此 `dp[0]` 也就相当于当前节点的左边向右移动到当前节点的路径数，也就相当于上面方法中的 `dp[i][j - 1]` 。同样的，`dp[1]` 其实也就相当于上一层的同一列的路径数，也就是 `dp[i - 1][j]` 。

最后结果就是 `dp[n - 1]` 。

**代码**

```java
class Solution {
    public int uniquePaths(int m, int n) {
        int[] dp = new int[n];
        Arrays.fill(dp, 1);
        for(int i = 1; i < m; i++){
            for(int j = 1; j < n; j++){
                dp[j] = dp[j] + dp[j - 1];
            }
        }
        return dp[n - 1];
    }
}
```

