### 题目描述

给定一个正整数 *n*，生成一个包含 1 到 *n*2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。

**示例:**

```
输入: 3
输出:
[
 [ 1, 2, 3 ],
 [ 8, 9, 4 ],
 [ 7, 6, 5 ]
]
```

### 解题方法

如果您做过 [54. 螺旋矩阵](https://leetcode-cn.com/problems/spiral-matrix/) ，您应该不会对这种题目感到陌生，您也可以查看我关于这道题目的题解。

#### 主要思想

顺时针螺旋扫描矩阵，在其上放置其应该放置的数字。

- 如何顺时针扫描？

  首先，我们需要**对矩阵进行分层**，比如：

  |  1   |  2   |  3   |
  | :--: | :--: | :--: |
  |  8   |  9   |  4   |
  |  7   |  6   |  5   |

  我们可以分为两层，**最外层为：**

  |  1   |  2   |  3   |
  | :--: | :--: | :--: |
  |  8   |      |  4   |
  |  7   |  6   |  5   |

  **最内层** 就只剩下数字 `9` 了。

  对于每一层，我们再进行顺时针扫描就很简单了。

  - 从左向右扫描当前层上方行
  - 从上到下扫描最右一列（不包括第一个和最后一个，因为在扫描行的时候就已经扫描到了）
  - 从右向左扫描当前层下方行
  - 从下到上扫描最左一列（不包括第一个和最后一个，因为在扫描行的时候就已经扫描到了）

  这就是一层的顺时针扫描，接下来就是其他层的了，同时这也就是对螺旋的操作。

- 如何进行螺旋扫描？

  上面我们提到对矩阵进行分层，在这里我们使用变量来标记层。

  - `row` ：当前层的上方行索引，由于矩阵为 `n x n` 的，这同时也是最左列的列索引
  - `col` ：当前层的下方行索引，同时也是最右列的列索引

  由此，我们也可以发现 `(row,row)` 即为当前层形成的矩阵的左上角，而 `(col,col)`即为右下角。

  接下来就是螺旋扫描了。

  其实，如果按照我们上面的顺时针顺序扫描一层后，**如果能进入到下一层，其实也就是螺旋操作**了。如果您不能理解，可以看下这个 `4 x 4` 的矩阵。

  |  1   |  2   |  3   |  4   |
  | :--: | :--: | :--: | :--: |
  |  12  |  13  |  14  |  5   |
  |  11  |  16  |  15  |  6   |
  |  10  |  9   |  8   |  7   |

  进入下一层也很简单，只需要 `row++` ，`col--` 即可。

#### 算法步骤

	- 初始化 `row` ，`col` 
 - 当 `row < col` 时循环
   - 访问当前层上方行
   - 访问当前层最右列
   - 访问当前层下方行
   - 访问当前层最左列
   - 进入下一层
- 若 `row == col` ，说明为 `n` 为奇数，最后还有一个中心数组元素需要初始化（**细节**）
- 返回矩阵

#### 代码

```java
class Solution {
    public int[][] generateMatrix(int n) {
        int[][] matrix = new int[n][n];
        int num = 1, row = 0, col = n - 1;
        while(row < col){
            for(int i = row; i <= col; i++)    matrix[row][i] = num++;
            for(int i = row + 1; i < col; i++)    matrix[i][col] = num++;
            for(int i = col; i >= row; i--)    matrix[col][i] = num++;
            for(int i = col - 1; i > row; i--)    matrix[i][row] = num++;
            row++;
            col--;
        }
        if(row == col)    matrix[row][col] = num;
        return matrix;
    }
}
```

