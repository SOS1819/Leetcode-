### 题目描述

给定一个整数 *n*，求以 1 ... *n* 为节点组成的二叉搜索树有多少种？

**示例:**

```
输入: 3
输出: 5
解释:
给定 n = 3, 一共有 5 种不同结构的二叉搜索树:

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
```

### 解题方法

这道题目的升级版是 [95. 不同的二叉搜索树 II](https://leetcode-cn.com/problems/unique-binary-search-trees-ii/) ，也是非常好的一道题目。

#### 1. 动态规划

我们定义一个数组 `dp[i]` ，其代表**由 `i` 个节点可以组成的二叉搜索树数**，注意不是 1 ... *i* 可以组成的，因为在数量上来说 1 ... *i* 和 2 ... *i + 1* 的数量是相等的。

那么我们接下来的主要操作还是和 [95. 不同的二叉搜索树 II](https://leetcode-cn.com/problems/unique-binary-search-trees-ii/) 一样，**在区间内挑选根节点，分割区间，列状态转移方程** 。

先从例子进行分析：

- 当 `n = 0` 时，显然 `dp[0] = 1` ，只有一棵空树
- 当 `n = 1` 时，`dp[1] = 1` 
- 当 `n = 2` 时，我们开始挑选根节点
  - 首先，可供选择的根节点有 `[1,2]` ，这也是我们的节点区间
  - 若我们选择 `1` 作为根节点，那么其左子树的区间为 `[]` ，右子树的区间为 `[2]` ，这时左子树的节点数为 `0` ，因此可能形成的左子树只有一种（空树），而右子树节点数为 `1` ，也只有一种，刚好和 `dp[0]` 和 `dp[1]` 对应，那么对于左右子树进行两两组合（相乘），我们可以得到选择 `1` 作为根节点最终可以形成 `1` 种二叉搜索树。
  - 同样，对于选择 `2` 作为根节点，也是只有一种二叉搜索树
  - 最后，我们得到 `dp[2] = 2 ` 
- 当 `n = 3` 时，可供选择的根节点有 `[1,2,3]` 
  - 当选择 `1` 作为根节点时，同样左子树区间为空，右子树区间为 `[2,3]` ，左子树节点数为 `0` ，右子树节点数为 `2` ，由于我们提到 `dp[i]` 的定义，因此右子树的可能形状其实也就是 `dp[2]` 了，所以选择 `1` 作为根节点的总数为 `1 x 2 = 2`
  - 当选择 `2` 时，同样可以得到为 `1 x 1 = 1` 
  - 当选择 `3` 时，为 `2 x 1 = 2` 

从上面我们可以得出状态转移方程，$dp[i] = dp[j - 1] + dp[i - j]$ ，其中 `j` 代表从区间 `[1,i]` 中任意选择的一个根节点。

##### 代码

```java
class Solution {
    public int numTrees(int n) {
        if(n == 0)    return 0;
        int[] dp = new int[n + 1];
        dp[0] = 1;
        dp[1] = 1;
        for(int i = 2; i <= n; i++){
            for(int j = 1; j <= i; j++){
                dp[i] += (dp[j - 1] * dp[i - j]);
            }
        }
        return dp[n];
    }
}
```

#### 2. 卡塔兰数

这谁知道啊。。。求通项公式。。
$$
C_0 = 1, \qquad C_{n+1} = \frac{2(2n+1)}{n+2}C_n \qquad \qquad 
$$
那么其实我们前面动态规划过程中的第二层循环就是在计算 $C~n + 1$ 了

需要注意的是，我们需要先用 `long` 存储对应的结果，在返回时再转化为 `int` ，因为在乘法过程中产生的中间结果可能会溢出。

##### 代码

```java
class Solution {
    public int numTrees(int n) {
        long res = 1;
        for(int i = 0; i < n; i++){
            // Ci 代表的就是 Cn
            res = (((i << 1) + 1) << 1) * res / (i + 2);
        }
        return (int)res;
    }
}
```

