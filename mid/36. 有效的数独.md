### 题目描述

判断一个 9x9 的数独是否有效。只需要**根据以下规则**，验证已经填入的数字是否有效即可。

1. 数字 `1-9` 在每一行只能出现一次。
2. 数字 `1-9` 在每一列只能出现一次。
3. 数字 `1-9` 在每一个以粗实线分隔的 `3x3` 宫内只能出现一次。

![img](https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png)

​                                                                 上图是一个部分填充的有效的数独。

数独部分空格内已填入了数字，空白格用 `'.'` 表示。

**示例 1:**

```
输入:
[
  ["5","3",".",".","7",".",".",".","."],
  ["6",".",".","1","9","5",".",".","."],
  [".","9","8",".",".",".",".","6","."],
  ["8",".",".",".","6",".",".",".","3"],
  ["4",".",".","8",".","3",".",".","1"],
  ["7",".",".",".","2",".",".",".","6"],
  [".","6",".",".",".",".","2","8","."],
  [".",".",".","4","1","9",".",".","5"],
  [".",".",".",".","8",".",".","7","9"]
]
输出: true
```

**示例 2:**

```
输入:
[
  ["8","3",".",".","7",".",".",".","."],
  ["6",".",".","1","9","5",".",".","."],
  [".","9","8",".",".",".",".","6","."],
  ["8",".",".",".","6",".",".",".","3"],
  ["4",".",".","8",".","3",".",".","1"],
  ["7",".",".",".","2",".",".",".","6"],
  [".","6",".",".",".",".","2","8","."],
  [".",".",".","4","1","9",".",".","5"],
  [".",".",".",".","8",".",".","7","9"]
]
输出: false
```

**说明:**

- 一个有效的数独（部分已被填充）不一定是可解的。
- 只需要根据以上规则，验证已经填入的数字是否有效即可。
- 给定数独序列只包含数字 `1-9` 和字符 `'.'` 。
- 给定数独永远是 `9x9` 形式的。



### 解题方法

本来想做个咸鱼扫三次得了。。奈何评论区太过牛批。。学习学习还是。

**优化方法：使用位串记录信息**

定义三个整数 `row` 、`col` 以及 `square` 分别代表某一行、某一列以及某一个九宫格是否有效，若存在任何一个无效，返回 `false` 即可。

**记录方法：使用整数32位中的低[1, 9]位记录对应某一行、某一列以及某一个九宫格中对应的数字是否已存在**

*PS：这里假设最低位为第 `0` 位*

例如，假设某一行序列为 `1534.....` ，那么对应 `row` 的二进制低 `[1,9] `位为 `000011101` 。

当我们需要加入一个数字时，可以使用如下判断方法：

假设需要在某一行中加入数字 `n` ，我们可以将 `1` 左移 `n` 位与原来的 `row` 进行 **异或** 运算，并更新 `row` 。当然，在这之前我们需要判断是否已存在，判断方法为 将原来的 `row` 右移 `n` 位，并将结果与 `1`进行 **与** 运算，目的就是查看当前位是否已被记录。

由于我们记录的是某一行、某一列、某一个九宫格的对应的数字情况，因此我们的扫描顺序并不在按照普通的行序或者列序，我们需要另外做坐标的转换。

**注意：下面的提到的 `i`, `j` 均属于 `[0: 8]` 范围内，我们将棋盘由上到下分为9行，由左到右分为9列，由左到右以及由上到下分为9个九宫格**

- 行坐标转换

  若当前处理到第 `i` 行第 `j` 个数字，其在输入数独棋盘中的对应坐标其实也就是 `(i, j)`

- 列坐标转换

  若当前处理到第 `i` 列第 `j` 个数字，其在输入数独棋盘中的对应坐标其实也就是 `(j, i)`

- 九宫格坐标转换

  若当前处理到第 `i` 个九宫格的第 `j` 个数字，其在输入数独中的对应坐标其实也就是 `((i / 3) * 3 + (j / 3), (i % 3) * 3 + (j % 3))`， 如下图所示，该图来自[题解](https://leetcode-cn.com/problems/valid-sudoku/solution/java-wei-yun-suan-xiang-jie-miao-dong-zuo-biao-bia/)，在该题解中有着更为详细的坐标转换讲解以及图示，建议查看

![image.png](https://pic.leetcode-cn.com/4bf9994d56f87dc4f45727793438bd99e7eaa2c4ab663fd25950b7f9d6faafdf-image.png)

转换完坐标后便可以利用上面的位串进行存储运算了。

#### 代码

```java
class Solution {
    public boolean isValidSudoku(char[][] board) {
        if(board == null)    return false;
        for(int i = 0; i < 9; i++){
            int row = 0, col = 0, square = 0;
            for(int j = 0; j < 9; j++){
                // . 的ASCII码为46
                // 转换坐标,找到对应坐标位置的数字
                int r = board[i][j] - '0';
                int c = board[j][i] - '0';
                int s = board[(i / 3) * 3 + (j / 3)][(i % 3) * 3 + (j % 3)] - '0';
                row = r > 0 ? check(row, r) : row;
                col = c > 0 ? check(col, c) : col;
                square = s > 0 ? check(square, s) : square;
                if(row == -1 || col == -1 || square == -1)    return false;
            }
        }
        return true;
    }

    /* 判断当前位置是不是已经存在
     * 若存在,返回-1,否则返回处理后的数(位串))
     */
    private int check(int num, int n){
        return ((num >> n) & 1) == 1 ? -1 : num ^ (1 << n);
    }
}
```

