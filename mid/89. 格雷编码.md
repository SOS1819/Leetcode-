### 题目描述

格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个位数的差异。

给定一个代表编码总位数的非负整数 *n*，打印其格雷编码序列。格雷编码序列必须以 0 开头。

**示例 1:**

```
输入: 2
输出: [0,1,3,2]
解释:
00 - 0
01 - 1
11 - 3
10 - 2

对于给定的 n，其格雷编码序列并不唯一。
例如，[0,2,3,1] 也是一个有效的格雷编码序列。

00 - 0
10 - 2
11 - 3
01 - 1
```

**示例 2:**

```
输入: 0
输出: [0]
解释: 我们定义格雷编码序列必须以 0 开头。
     给定编码总位数为 n 的格雷编码序列，其长度为 2n。当 n = 0 时，长度为 20 = 1。
     因此，当 n = 0 时，其格雷编码序列为 [0]。
```

### 解题方法

这道题目看了挺久，还是参考了几个题解才写出来。

虽然题目的指示是使用回溯算法，但是我这里采用的是 **动态规划** 算法。

那么使用动态规划，我们首先要做的就是从综合小问题来求解大问题，因此我们从例子来看看规律。

当 `n = 0` 时，答案为 `[0]`

当 `n = 1` 时，答案为`[0, 1]`

当 `n = 2` 时，答案为 `[00,01,11,10]` 

当 `n = 3` 时，答案为 `[000,001,011,010,110,111,101,100]` 

盗用一张 [Gray Code （镜像反射法，图解）](https://leetcode-cn.com/problems/gray-code/solution/gray-code-jing-xiang-fan-she-fa-by-jyd/) 中的图就是：

![img](https://pic.leetcode-cn.com/28acf6d5b1fae0fb2dddbedd7ac92ffeee8902cd28233bdfb08b52af411a9bb2-Picture4.png)

由于 `n = 0` 是一个特殊情况，因此我们从 `n = 1` 开始看起。

此时 `n = 1` 时，全部的答案为 `[0,1]`

那么当 `n = 2` 时， 我们就可以利用 `n = 1` 的答案了。因为我们只需要在 `[0,1]` 中各元素前添加一个`0` 的得到 `[00,01]` ，但是实际上在前面添加 `0` 的话，对于数值是没有变化的，所以我们只需要套用 `n = 1` 的答案即可。

那么剩下的就是下半部分的 `[11,10]` 的求解了。如果我们按照上面的方法简单的在前面加 `1` 的话，那么是不满足格雷码的性质的。

那么仔细观察的话，对于上图中两种颜色的部分中的二进制串中，除了第一位，其它位的数字是对称的。比如 `[01]` 和 `[11]` 的第二位都为 `1` 。

也就是说，我们只需要将 `n = 1` 的答案逆序遍历并且各个元素首位前添加 `1` 后添加到答案中。

那么还剩下的就是如果添加 `0` 和 添加 `1` 了。

对于添加 `0` ，其实我们不需要操作了，因为不会改变数值。

对于添加 `1` ，由于我们是对应于二进制位添加 `1` ，因此实际上我们需要将原来的结果加上 `1<<(n-1)` 。

#### 代码

```java
class Solution {
    public List<Integer> grayCode(int n) {
        List<Integer> res = new ArrayList<>(){{add(0);}};
        int head = 1;       // 作为当前需要添加的1
        for(int i = 0; i < n; i++){
            for(int j = res.size() - 1; j >= 0; j--){
                res.add(head + res.get(j));
            }
            head <<= 1;
        }
        return res;
    }
}
```

#### 复杂度

- 时间复杂度：$O (2^n)$
- 空间复杂度：$O (2^n)$