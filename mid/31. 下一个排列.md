### 题目描述

实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。

如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。

必须**[原地](https://baike.baidu.com/item/原地算法)**修改，只允许使用额外常数空间。

以下是一些例子，输入位于左侧列，其相应输出位于右侧列。

`1,2,3` → `1,3,2`

`3,2,1` → `1,2,3`

`1,1,5` → `1,5,1`

### 解题方法

就用一个例子来说明吧。

假设我们的输入是 `11235432` ，对于我们自己来说，可以看出结果为 `11242335` 。

首先，如果我们将数字序列组成一个整数的话，那么下一个排列组成的整数在数轴上应该离当前整数最近。

所以我们可以确定的是，两个序列的相同的前缀数字越多，那么组成的整数距离越近。如果没有相同的前缀数字，则后一个排列组成的数越小越好。举个例子，对于 `1212` 而言， `1221` 与其具有最多的相同前缀数字，因此最近。而对于 `1221` 来说，其后一个排列必定以 `2` 开头，因此最小为 `2112` 。

那么我们怎么找到相同前缀数字最多那个排列呢？**从后往前扫描，每两个数（假设为 `i` 和 `i + 1`）进行比较，当我们发现后一个数比前一个数大时，停止扫描**， 这时我们就找到了最多的相同前缀数字（索引为`[0: i - 1]`的数字序列），并且仅利用扫描过的数字我们就可以生成位于当前排列后的排列序列（因为 `nums[i] < nums[i + 1]`，即使我们简单地将这两个数兑换，也能产生位于当前排列后的排列序列，只是还不能确定是最小的）。举个例子，比如 `1212` ，我们发现 `nums[2] < nums[3]` ，所以我们停止，虽然这里对换 `nums[3 ` 和 `nums[2]` 也能得到答案，但是这只是巧合。因为对于 `1221` 来说，`nums[0] < nums[1]` ，交换的话就为 `2121` ，明显是不对的。

到这里，我们已经有效地缩小了所要求排列的范围，接下来我们需要保证其是最接近当前序列的，也就是序列组成的数字在数轴上离当前数字最近。

还是以例子来看，对于 `122431` 来说，我们可以发现 `nums[2] < nums[3]` ，所以其相同前缀数字序列为 `12` 。由于存在相同前缀，那么我们其实只需要找到后面的 `2431` 的下一个排列就可以了。**具体做法分为两步**：

- 以索引 `nums.length - 1` 为起点，向后扫描，找到第一个大于 `nums[i]`（找最多相同前缀数字结束时的索引）的数字 `nums[j]` 。两者交换。

  **为什么要这两个直接交换呢？** 因为我们扫描的序列具有一个特点，位于 `[i+1, nums.length - 1]` 的数字序列是降序排列的，比如 `2431` ， `i` 是数字 `2` 的索引，这也就说明，当前排列所组成的数字是以 `nums[i]`（这里为2） 开头的最大数字，也就是说，下一个排列开头的数字一定是大于 `nums[i]`  的数字中的最小值，这也是我们为什么从后往前扫描的原因。这一步，让我们又缩小了范围。

- 经过上一步后，我们的序列已经变为了 `3421 `，但是这还不是正确答案。由 `2431` 变为 `3421` 其实就是上面提到的，**如果没有相同的前缀数字，则后一个排列组成的数越小越好** 。`2431` 就是我们扫描后找到的没有相同前缀数字的序列了。接下来我们需要使其最小。

  观察 `3421` ,可以发现，上一步中提到的特点（降序排列）在这里仍然存在。这时以 `3`开头的最大数字，我们要找到以 `3` 开头的最小数字的话，只需要从 `nums[i + 1]` 到 `nums[length - 1]` 首尾对换即可，也就是将 `421` 首尾对换为 `124` 。

#### 代码

```java
class Solution {
    public void nextPermutation(int[] nums) {
        int length = nums.length, i = length - 2, j = length - 1;
        while(i >= 0 && nums[i] >= nums[i + 1]){
            // 找到对应位置
            i--;
        }
        if(i >= 0){
            while(j >= 0 && nums[j] <= nums[i]){
                j--;
            }
            swap(nums, i, j);
        }
        // 反转,把后面的全部反转
        i++;
        j = length - 1;
        while(i < j){
            swap(nums, i, j);
            i++;
            j--;
        }
    }

    private void swap(int[] nums, int i, int j){
        int tmp = nums[i];
        nums[i] = nums[j];
        nums[j] = tmp;
    }
}
```



 

