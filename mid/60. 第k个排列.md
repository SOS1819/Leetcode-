### 题目描述

给出集合 `[1,2,3,…,*n*]`，其所有元素共有 *n*! 种排列。

按大小顺序列出所有排列情况，并一一标记，当 *n* = 3 时, 所有排列如下：

1. `"123"`
2. `"132"`
3. `"213"`
4. `"231"`
5. `"312"`
6. `"321"`

给定 *n* 和 *k*，返回第 *k* 个排列。

**说明：**

- 给定 *n* 的范围是 [1, 9]。
- 给定 *k* 的范围是[1,  *n*!]。

**示例 1:**

```
输入: n = 3, k = 3
输出: "213"
```

**示例 2:**

```
输入: n = 4, k = 9
输出: "2314"
```

### 解题方法

如果简单使用递归回溯求解的话，肯定太慢了。所以我们可以选择数学方法求解。

对于一个全排列来说，其排列总数为 $n!$  ，也就是 `n x (n - 1) x (n - 2) x...x 1 ` 。也就是说第一个数字有 `n` 种选择，第二个有 `n - 1` 种选择。因此对于一个确定的排列前缀 *a~1~...a~m~* 来说，其最终能够生成的排列总数也就是 $(n - m)!$ 。

现在题目要求将所有排列序列升序排列。

现在假如我们知道第一位是 `1` ，我们知道其能组成的所有排列总数为 $(n - 1)!$ ，因此其能组成的最大数 `1(n)(n - 1)...2` 自然位于第 $(n - 1)!$ 个。

那么反过来，现在我们知道其位于第 $(n - 1)!$ 个，我们只需将其除以剩余的位数的阶乘就可以得到第一位 为`1`。

这也就是我们用数学方法求解的基础，**找到当前位应该放置的数字**。

现在假设我们知道其位于第 `k` 为，总位数为 `n` ，如果我们将 ` k` 除以 $(n - 1)!$ 得到 `rank` ，那么就得到了第一位的数字为 `rank` 或者 `rank + 1`。为什么会有两种可能呢？因为整数除法会向下取整。让我们看两个例子：

- 例子1，`k = 6` ，`n = 3` ，那么 `rank = 3` ，当**能整除**时，其说明第 `k` 个排列序列就是以 `3` 开头的最大的数字序列，即为 `321`。
- 例子2，`k = 9` ，`n = 4` ，那么 `rank = 1  `，此时**不能整除** ，余数为 `3` ，说明其开头应该为 `2` ，而不是`1`。

因此，我们需要在能够整除时进行特判，使得 `rank--` ，找到第 `rank - 1` 小（因为我是从 `0` 开始计数的，因此 `rank - 1` 实际上就是第 `rank`小的元素）。

但是此时，我们只是找到了第一位，后面的怎么办呢？

- 当能**整除**时，其**序列是当前排列前缀能够组成的最大数字序列**，说明后面的数字应该选择是**当前未选择的数字中最大的**，为了统一计算，我们令 `k = (n - 1)!` ，还剩余`n - 1 ` 位待选择，这样我们重复上述操作将 `k` 除以 $(n - 2)!$ ，就能在下次循环中找到第 `n - 1` 小的数字，也就是未选择数字中最大的。
- 当**不能整除**时，我们将 `k % (n - 1)!` 赋给 `k` 进入下一次循环即可。

#### 代码

```java
class Solution {
    public String getPermutation(int n, int k) {
        boolean[] used = new boolean[n];		// 标记对应数字(下标要减1)是否已使用过
        StringBuilder buider = new StringBuilder();
        int divisor = 1;
        for(int i = 2; i < n; i++)    divisor = divisor * i;
        for(int cur = n - 1; cur >= 1; cur--){
            int rank = k / divisor;    // 当前需要未选择的数字位于第rank或者rank+1(从0开始)
            k = k % divisor;
            if(k == 0){    // 特判,此时位于第rank个,并且后面都是由大到小排列
                k = divisor;
                rank--;
            }        
            int choosenIndex = 0;
            while(choosenIndex < n && rank >= 0){
                if(!used[choosenIndex++]){
                    rank--;
                }
            }
            used[choosenIndex - 1] = true;
            buider.append(choosenIndex);
            divisor = divisor / cur;
        }
        // 加上最后一位
        for(int i = 0; i < n; i++){
            if(!used[i]){
                buider.append(i + 1);
                break;
            }
        }
        return buider.toString();
    }
}
```

