### 题目描述

给定一个包含非负整数的 *m* x *n* 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

**说明：**每次只能向下或者向右移动一步。

**示例:**

```
输入:
[
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
输出: 7
解释: 因为路径 1→3→1→1→1 的总和最小。
```

### 解题方法

这道题和前面的 [62. 不同路径](https://leetcode-cn.com/problems/unique-paths/) 和 [63. 不同路径 II](https://leetcode-cn.com/problems/unique-paths-ii/) 很相似，都是使用 **动态规划** 算法，并且转移方程基本是一个模式。如果您没有尝试过前两题的话，推荐您尝试解答，也可以参考我对应的题解进行解答。

我们使用一个二维数组 `dp` 来保存对应中间计算结果，但是由于题目并不要求我们不能改动原数组，因此我们可以直接将数组 `gird` 当作我们的 `dp` 数组操作。

那么，`grid[i][j]` 代表由左上角 `[0,0]` 到达当前点 `[i,j]` 的最小路径和，那么 `grid[0][0]` 即为其初始值。

而 `grid[i][0] += grid[i - 1][0] ` ，对于第一列来说，其只能由上方节点到达当前节点，同样对于第一行来说，`grid[0][i] += grid[0][i - 1]` ，其只能由左方节点到达当前节点。这也就是我们的初始化过程。

接下来就是转移方程：`grid[i][j] += min(grid[i - 1][j], grid[i][j - 1])` ，对于当前节点，只有其左方节点和上方节点能够到达该节点，因此我们选择两者中的较小值加上自身，便找到了由左上角到达当前节点的最小路径和。

那么，最后答案也就是 `grid[m - 1][n - 1]` 了。

**当然如果题目不允许修改原数组，那么我们可以另外创建一个二维 `dp` 数组保存计算结果，也可以优化为一维数组进行保存，具体细节可以查看我前两题的题解，并且也建议您尝试解答上两题。**

#### 代码

```java
class Solution {
    public int minPathSum(int[][] grid) {
        if(grid == null || grid.length == 0 || grid[0].length == 0)    return 0;
        int m = grid.length, n = grid[0].length;
        for(int i = 1; i < m; i++)    grid[i][0] += grid[i - 1][0];
        for(int i = 1; i < n; i++)    grid[0][i] += grid[0][i - 1];
        for(int i = 1; i < m; i++){
            for(int j = 1; j < n; j++){
                grid[i][j] += Math.min(grid[i - 1][j], grid[i][j - 1]);
            }
        }
        return grid[m - 1][n - 1];
    }
}
```

